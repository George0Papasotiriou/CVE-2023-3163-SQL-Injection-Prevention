-- Function to validate the order by clause in the current user's schema
CREATE OR REPLACE FUNCTION isValidOrderBySql(p_value VARCHAR2) RETURN BOOLEAN AS
    v_sql_pattern VARCHAR2(500) := '[[:alnum:]_ ,.]+';
BEGIN
    RETURN (REGEXP_LIKE(p_value, v_sql_pattern));
END;
/

-- Procedure to check for SQL keywords in the current user's schema
CREATE OR REPLACE PROCEDURE filterKeyword(p_value VARCHAR2) AS
    v_sql_regex VARCHAR2(500) := 'and |extractvalue|updatexml|exec |insert |select |delete |update |drop |count |chr |mid |master |truncate |char |declare |or |+|user()';
    v_sql_keywords VARCHAR2(32767);
BEGIN
    IF p_value IS NULL OR LENGTH(p_value) = 0 THEN
        RETURN;
    END IF;
    
    v_sql_keywords := REGEXP_REPLACE(v_sql_regex, '\|', ',');
    
    FOR k IN (SELECT COLUMN_VALUE AS sql_keyword FROM XMLTABLE(v_sql_keywords)) LOOP
        IF INSTR(UPPER(p_value), UPPER(k.sql_keyword)) > 0 THEN
            RAISE_APPLICATION_ERROR(-20001, 'The parameter poses a SQL injection risk');
        END IF;
    END LOOP;
EXCEPTION
    WHEN OTHERS THEN
        RAISE_APPLICATION_ERROR(-20001, 'An error occurred during SQL keyword filtering');
END;
/

-- Usage examples in the current user's schema
DECLARE
    v_order_by_clause VARCHAR2(100) := 'name ASC, age DESC';
    v_user_input VARCHAR2(100) := 'SELECT * FROM users';
    v_current_schema VARCHAR2(30);
BEGIN
    SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') INTO v_current_schema FROM DUAL;
    
    IF isValidOrderBySql(v_order_by_clause) THEN
        -- Proceed with using the order by clause in your SQL query
        DBMS_OUTPUT.PUT_LINE('Valid order by clause: ' || v_order_by_clause);
    ELSE
        -- Handle the case where the order by clause is not valid
        RAISE_APPLICATION_ERROR(-20001, 'The order by clause is not valid');
    END IF;
    
    filterKeyword(v_user_input);
    
    -- Proceed with using the user input in your SQL query
    DBMS_OUTPUT.PUT_LINE('User input: ' || v_user_input);
EXCEPTION
    WHEN UtilException THEN
        -- Handle the case where a SQL injection risk is detected
        DBMS_OUTPUT.PUT_LINE('An SQL injection risk is detected');
    WHEN OTHERS THEN
        -- Handle other exceptions
        DBMS_OUTPUT.PUT_LINE('An error occurred: ' || SQLERRM);
END;
/